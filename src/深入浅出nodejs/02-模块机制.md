# 第二章 模块机制

本章内容主要讲解Node中的模块机制，书中涉及到的内容较深，对于较深部分，我选择暂时略过。

本文会结合Node的模块机制和ES6的模块化进行学习分析。



javaScript发展初期没有有模块化的涉及，但是随着互联网的发展，单纯通过script标签引入js文件，会使得代码杂乱不堪，至此JavaScript社区出现了Commonjs

## 2.1 CommonJS 规范

最初愿景：希望JavaScript可以在任何地方运行。

### 2.1.1 CommonJS的出发点

JavaScript发展初期规范标准确实：

- 缺少模块化系统的规范
- 标准库较少，尤其是对于文件系统、I/O流等常见需求
- 没有标准接口
- 缺乏包管理系统

而CommonJs主要就是为了弥补上面的缺陷，以提高JavaScript具备开发大型应用的基础能力。

期望通过CommonJs API可以写出的应用具备跨宿主环境执行的能力。可以实现：

- 服务端JavaScript应用程序
- 命令行工具
- 桌面图形界面应用程序
- 混合应用

Node的模块化机制是借鉴CommonJs规范实现的一套模块系统。

### 2.1.2 CommonJS的模块化规范

1. 模块引入，require方法接受模块标识(一个符合小驼峰命名的字符串或者以.、..开头的相对路径或者绝对路径)，可以引入一个模块的API到当前上下文。

```js
const math = require('math')
```

2. 模块定义，exports负责将当前模块中的方法或者变量进行导出。在模块中还存在一个module对象，代表模块自身，exports是module的属性。

```js
exports.add = function (a, b) {
  console.log("add")
  return a + b
}
```

第二种方式：

```js
function add (a, b) {
  return a + b
}

module.exports = {
  add
}
```

## 2.2 Node的模块实现

Node中引入模块的三个步骤：

1. 路径分析
2. 文件定位
3. 编译执行



模块分类：

- Node提供的模块，称为核心模块，如 http、file、path
  - 核心模块部分在Node的源代码的编译过程中，编译进了二进制执行文件。Node进程启动的过程中，核心模块直接被加载至内存中
  - 所以核心模块在引入过程中，可以跳过文件定位和编译执行，并在路径分析过程中优先判断
  - 所以它的加载湿度是最快的
- 用户编写的模块，称为文件模块
  - 文件模块是在运行时动态加载，需要进行完整的路径分析、文件定位、编译执行
  - 故速度较慢

### 2.2.1模块加载优先从缓存中加载

- Node会对引入过的模块进行缓存，减少二次引入时的开销
- Node缓存的时模块经过编译执行之后的对象

1. #### 模块标识符分析

   模块标识符分析主要分为以下几类：

   - 核心模块，核心模块的优先级次于缓存加载。
   - 路径形式的文件模块，以.、..和/开始的标识符，都被作为文件模块来处理。require方法会将相对路径转为真实路径，以真实路径作为索引，将编译执行之后的结果放入缓存中。其加载速度慢于核心模块
   - 自定义模块，如我们常用的node_modules。是一种特殊的文件模块。Node在加载过程中会通过目录链进行查找加载，所以文件路径越深，查找时间就越长，加载速度就越慢。

2. #### 文件定位

- 文件扩展名分析：.js ==> .json ==>.node。引入模块的时候，最好带上扩展名。
- 目录分析和包：会通过package.json，解析出包的描述对象。没有package.json，则以index当做默认文件名。

### 2.2.3模块编译



